@startuml
autonumber

title Snowflake URL Shortener Sequences (Hexagonal & DDD)

actor Client
participant "Scheduler" as Scheduler

box "Adapter (Inbound) - WebFlux" #LightBlue
    participant "ShortenerHandler" as Handler
end box

box "Application Layer - Usecase" #LightYellow
    participant "ShortenUrlUseCase" as ShortenUseCase
    participant "RetrieveUrlUseCase" as RetrieveUseCase
    participant "WorkerCleansingUseCase" as CleansingUseCase
    participant "WorkerHeartbeatUseCase" as HeartbeatUseCase
end box

box "Domain Layer - Core Logic" #LightGreen
    participant "ShortUrlGenerator" as Generator
    participant "PooledIdGenerator" as IdGen
    participant "Base62Encoder" as Encoder
end box

box "Ports (Hexagonal - Outbound)" #Orange
    participant "UrlPort" as UrlPort
    participant "WorkerPort" as WorkerPort
end box

box "Adapter (Outbound) - Persistence" #LightPink
    participant "UrlPersistenceAdapter" as UrlAdapter
    participant "WorkerPersistenceAdapter" as WorkerAdapter
end box

database "MariaDB (R2DBC)" as DB

== Scenario 1: Shorten URL ==

Client -> Handler: POST /shorten { "url": "..." }
activate Handler
note right of Handler: [Inbound Adapter]\nHandles incoming web requests.

Handler -> ShortenUseCase: shorten(longUrl)
activate ShortenUseCase
note right of ShortenUseCase: [Application Service]\nOrchestrates domain logic, manages transactions.

' Use Case interacts with the Port, not directly with the adapter implementation.
ShortenUseCase -> UrlPort: findByLongUrl(longUrl)
activate UrlPort
' Port delegates to its implementing Adapter.
UrlPort -> UrlAdapter: findByLongUrl(longUrl)
activate UrlAdapter
UrlAdapter -> DB: SELECT * FROM urls WHERE long_url = ?
activate DB
DB --> UrlAdapter: (null or existing mapping)
deactivate DB
UrlAdapter --> UrlPort: (null or existing mapping)
deactivate UrlAdapter
UrlPort --> ShortenUseCase: (null or existing mapping)
deactivate UrlPort

alt New URL
    ShortenUseCase -> Generator: generate()
    activate Generator
    note right of Generator: [Domain Service]\nGenerates a unique short URL.
    Generator -> IdGen: nextId()
    activate IdGen
    IdGen --> Generator: Snowflake ID
    deactivate IdGen
    Generator -> Encoder: encode(ID)
    activate Encoder
    Encoder --> Generator: Short String Key
    deactivate Encoder
    ' Check for short URL existence via Port
    Generator -> UrlPort: existsByShortUrl(shortKey)
    activate UrlPort
    UrlPort -> UrlAdapter: existsByShortUrl(shortKey)
    activate UrlAdapter
    UrlAdapter -> DB: EXISTS(...)
    activate DB
    DB --> UrlAdapter: false
    deactivate DB
    UrlAdapter --> UrlPort: false
    deactivate UrlAdapter
    UrlPort --> Generator: false
    deactivate UrlPort
    Generator --> ShortenUseCase: Generated Short URL
    deactivate Generator

    note right of ShortenUseCase: Creates domain object (UrlMapping) and saves it via Port.
    ShortenUseCase -> UrlPort: save(urlMapping)
    activate UrlPort
    UrlPort -> UrlAdapter: save(urlMapping)
    activate UrlAdapter
    UrlAdapter -> DB: INSERT INTO urls ...
    activate DB
    DB --> UrlAdapter: Success
    deactivate DB
    UrlAdapter --> UrlPort: Saved UrlMapping
    deactivate UrlAdapter
    UrlPort --> ShortenUseCase: Saved UrlMapping
    deactivate UrlPort
else Existing URL
    ' ShortenUseCase already received existing mapping from UrlPort
end

ShortenUseCase --> Handler: UrlMapping result
deactivate ShortenUseCase

Handler --> Client: 201 Created { "shortUrl": "..." }
deactivate Handler

== Scenario 2: Retrieve URL and Redirect ==

Client -> Handler: GET /{shortKey}
activate Handler
note right of Handler: [Inbound Adapter]\nHandles short URL lookup.

Handler -> RetrieveUseCase: retrieve(shortKey)
activate RetrieveUseCase
note right of RetrieveUseCase: [Application Service]\nRetrieves original URL.

RetrieveUseCase -> UrlPort: findByShortUrl(shortKey)
activate UrlPort
UrlPort -> UrlAdapter: findByShortUrl(shortKey)
activate UrlAdapter
UrlAdapter -> DB: SELECT * FROM urls WHERE short_url = ?
activate DB
DB --> UrlAdapter: Row data
deactivate DB
UrlAdapter --> UrlPort: UrlMapping? (Nullable)
deactivate UrlAdapter
UrlPort --> RetrieveUseCase: UrlMapping? (Nullable)
deactivate UrlPort

RetrieveUseCase --> Handler: UrlMapping?
deactivate RetrieveUseCase

alt URL Found
    note right of Handler: [Inbound Adapter]\nResponds with 302 Redirect.
    Handler --> Client: 302 Found (Location: "originalUrl")
else Not Found
    note right of Handler: [Inbound Adapter]\nResponds with 404 Not Found.
    Handler --> Client: 404 Not Found
end
deactivate Handler


== Scenario 3: Cleanse Idle Workers ==

note over Scheduler, CleansingUseCase: Scheduled task to clean up idle workers.
Scheduler -> CleansingUseCase: cleanseIdleWorkers()
activate CleansingUseCase
note right of CleansingUseCase: [Application Service]\nFinds workers inactive for > 5 minutes.

CleansingUseCase -> WorkerPort: findInactiveWorkers(threshold)
activate WorkerPort
WorkerPort -> WorkerAdapter: findInactiveWorkers(threshold)
activate WorkerAdapter
WorkerAdapter -> DB: SELECT * FROM snowflake_workers WHERE status = 'ACTIVE' AND updated_at < :threshold
activate DB
DB --> WorkerAdapter: Flow<WorkerEntity>
deactivate DB
WorkerAdapter --> WorkerPort: Flow<Worker>
deactivate WorkerAdapter
WorkerPort --> CleansingUseCase: Flow<Worker>
deactivate WorkerPort

alt Idle Workers Found
    note right of CleansingUseCase: [Application Service]\nUpdates status of found workers via Port.
    CleansingUseCase -> WorkerPort: cleanseWorkers(workerIds, newStatus)
    activate WorkerPort
    WorkerPort -> WorkerAdapter: cleanseWorkers(workerIds, newStatus)
    activate WorkerAdapter
    WorkerAdapter -> DB: UPDATE snowflake_workers SET ... WHERE worker_id IN (...)
    activate DB
    DB --> WorkerAdapter: Update count
    deactivate DB
    WorkerAdapter --> WorkerPort: Update count
    deactivate WorkerAdapter
    WorkerPort --> CleansingUseCase: Updated count
    deactivate WorkerPort
else No Idle Workers
    note right of CleansingUseCase: No workers to clean up.
end
CleansingUseCase --> Scheduler: Result (e.g., updated count)
deactivate CleansingUseCase


== Scenario 4: Worker Heartbeat ==

Client -> Handler: POST /worker/heartbeat/{workerId} (or similar endpoint)
activate Handler
note right of Handler: [Inbound Adapter]\nReceives heartbeat signal from a worker.

Handler -> HeartbeatUseCase: recordHeartbeat(workerId)
activate HeartbeatUseCase
note right of HeartbeatUseCase: [Application Service]\nUpdates worker's last seen timestamp.

HeartbeatUseCase -> WorkerPort: updateWorkerLastSeen(workerId, now())
activate WorkerPort
WorkerPort -> WorkerAdapter: updateWorkerLastSeen(workerId, now())
activate WorkerAdapter
WorkerAdapter -> DB: UPDATE snowflake_workers SET updated_at = NOW() WHERE worker_id = ?
activate DB
DB --> WorkerAdapter: Success
deactivate DB
WorkerAdapter --> WorkerPort: Success
deactivate WorkerPort
WorkerPort --> HeartbeatUseCase: Success
deactivate WorkerPort

HeartbeatUseCase --> Handler: Success response
deactivate HeartbeatUseCase

Handler --> Client: 200 OK
deactivate Handler

@enduml